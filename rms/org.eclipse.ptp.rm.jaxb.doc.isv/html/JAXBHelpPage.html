<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>PTP Target System Configuration</title>
<link rel="stylesheet" type="text/css" href="help.css">
</head>
<body>
	<br>
	<h1>Target System Configuration</h1>

	<h3>
		<a name="PTP600">PTP 6.0.0 Changes</a>
	</h3>

	<p>A number of new
		features and changes have been included in the 6.0.0 release.</p>
	<ol>
		<li>The <code>property</code> element has been removed completely. Since properties and attributes
			were essentially identical, removing the <code>property</code> element reduces confusion as to when they should be
			used.</li>
		<li>The <code>buttonId</code> attribute on a <a href="#Widget"><code>widget</code></a> is now global. In the previous version
                       button IDs were local to each tab. This allows a button on one tab to change the state
                       of a control on a different tab;</li>
		<li>The <a href="#ControlState"><code>control-state</code></a> element now supports obtaining state by comparing
                       an <a href="#AttributeType"><code>attribute</code></a> value to a string;</li>
		<li>The <code>saveValueTo</code> attribute on a <a href="#Widget">widget</a> has been renamed to simply
                       <code>attribute</code>. This is to reflect the fact that an widget can read from and
                       save to an <a href="#AttributeType"><code>attribute</code></a>.</li>
        <li>The <a href="#LineArg"><code>arg</code></a> element now has an <a href="#AttributeType"><code>attribute</code></a> attribute. If
        				supplied, this will be compared to the <code>isUndefIfMatches</code> string rather than the element content in
        				order to determine if the argument is defined or not.
	</ol>
	
	<h3>
		<a name="PTP501">PTP 5.0.1 Changes</a>
	</h3>

	<p>Aside from some significant bug fixes, there are a number of new
		features with the 5.0.1 release.</p>
	<ol>
		<li>The <code>widget</code> component has been split up into
			three components: <a href="#Widget"><code>widget</code> </a>, <a
			href="#ButtonGroup"><code>button-group</code> </a>, and <a
			href="#Browse"><code>browse</code> </a>;</li>
		<li><a href="#Action"><code>action</code> </a> push-button
			functionality has been added;</li>
		<li><a href="#ControlState"><code>control-state</code> </a>
			elements have been added to all UI control descriptors;</li>
		<li>The launch tab <a href="#LaunchTab"><code>import</code> </a>
			controller type has been modified (largely for maintaining uniformity
			of implementation) to subclass the <code>dynamic</code> controller;</li>
		<li>Ability to inspect invisible discovered (excluded) properties
			and attributes via a "View" button (see <a href="#TabController">note</a>)
			has been added;</li>
		<li><a href="#Preferences">Preferences</a> have been added to
			help with the debugging of <a href="#StreamParsers">stream
				tokenizers</a>;</li>
		<li>Resource Manager "environment" handling has been totally
			rewritten in order to support the exclusion of properties associated
			with invisible or disabled widgets, and to allow for the restoration
			of their values when re-enabled.</li>
	</ol>

	<p>In addition, some tweaking of the SWT "knobs" was necessary to
		get the XML to reflect more closely the behavior of the Java classes
		(especially in terms of defaults).</p>
	<hr>

	<h2>
		<a name="Introduction">Introduction</a>
	</h2>

	<p>
		PTP allows you to launch and monitor
		applications on local or remote resources using systems
		which are configured from an XML file via JAXB (
		<code>javax.xml.bind</code>
		) technology.<br>
	</p>

	<p>The target system configuration files:</p>
	<ol>
		<li>Allow for maximum adaptability. Often job schedulers (PBS,
			LSF, LoadLeveler, etc.) or interactive runtime systems (OpenMPI, PE,
			SLURM, etc.) are set up by system administrators in special or
			non-standard ways which make it difficult to use a generic tool. The
			configuration file allows a user or community of users to fit the
			resource manager to a class of systems, to a single host, or even to
			special application usage.</li>
		<li>Simplify adding support for new systems. Building the resource manager 
			control system and its UI presentation from an
			XML configuration means that in most cases no special Java coding is
			necessary. Users should be able to accommodate new systems, at least
			on the client-end, without writing and loading additional Eclipse
			plugins. (The only qualification here is that the monitoring
			component also support that type of scheduler or runtime; see the
			following paragraphs.)</li>
	</ol>

	<p>
		A target system configuration consist of two components, a
		"control" component, which governs the configuration, launch and cancellation of
		individual jobs entirely from the client end, and a "monitoring" component, which
		displays job status as well as global information about the HPC
		resource. The monitoring system uses built-in types provided
		by the PTP distribution which support most standard scheduler types. Adding
		a new configuration will normally entail only the specification of
		its control part. The default mode of usage is that
		the client stages the necessary components (mostly Perl
		scripts) automatically, but in a future release, the monitor will also
		be capable of connecting directly to a system-wide (web-based)
		deployment.
	</p>
	
	<p>
		The "control" component of the target configuration is associated with a remote connection
		when the user configures a "Parallel Application" run configuration using the standard Eclipse launch
		configuration mechanism. This remote connection is the used whenever the control system 
		needs to send or receive data, such as when running a command, or copying a file.
	</p>
	
	<p>
		The "monitor" component of the target configuration is associated with a remote connection
		via the "Monitors" view in the "System Monitoring" perspective. This connection is used for
		sending and receiving data required to perform the monitoring activities. Note that the
		"control" and "monitor" component's remote connections are independent, although they can
		both share the same connection (which is the normal case).
	</p>
		
	<p>
		<b>The following is a guide to the target system configuration XML
			definition. Those interested only in using configurations
			already provided with the PTP distribution should consult the User
			Guide under the relevant scheduler section.</b>
	</p>
	<hr>
	<h2>
		<a name="Customizing"></a>Getting Started</a>
	</h2>

	<p>
		We provide <a href="http://download.eclipse.org/tools/ptp/docs/JAXBDemo.pdf">here</a> an introductory tutorial slide set demonstrating some
		simple additions to a pre-existing configuration file.
		For some example XML illustrating various aspects of the schema
		(particularly UI features), we also provide a <a
			href="http://download.eclipse.org/tools/ptp/docs/JAXBExamples_5.0.1.1.zip">.zip file (for PTP release 5.0.1)</a>.
	</p>

	<h3>
		<a name="Preferences"></a>Preferences
	</h3>

	<p>The preference options are aids for debugging configuration
		changes. The first turns off configuration file caching. This will ensure
		that when you make changes to the configuration, they will automatically be
		picked up by PTP.</p>

	<p>The other options are useful if you are writing a new stream
		tokenizer for a command; checking all four options usually produces
		quite a bit of output, so in that case it may be advisable to log the
		results to a file rather than stdout (at any rate the latter would be
		available only if PTP were running as an application within the
		Eclipse IDE platform, which is not the case for those modifying the
		XML simply from within the PTP package installation workspace).</p>
	<br>
	<div style="margin-left: 40px;">
		<img alt="Preferences" src="images/00Preferences.png"><br>
	</div>
	<hr>

	<h2>
		<a name="XSD"></a>Target System Configuration XML Schema<br>
	</h2>

	<p>
		PTP is <b><i>model-driven</i> </b>; this means
		that its functioning and appearance are determined by a set of
		definitions provided via an XML file. What follows is a detailed
		explanation of the schema governing the resource manager XML
		definition. The latest version of the target configuration schema is available at the URL <a href="http://eclipse.org/ptp/schemas/rm">http://eclipse.org/ptp/schemas/rm</a>.
	</p>

	<p>
		The top level of the XML configuration is the <code>resource-manager-data</code> type as shown in the diagram below.
		This type specifies all the information needed in order to submit, control, and monitor jobs on a target system.
	</p>
	
	<img alt="ResourceManagerData" src="images/01rm-data.png" />

	<p>
		The <code>resource-manager-data</code> comprises three elements: <code>site-data</code>,
		<code>control-data</code> and <code>monitor-data</code>. In addition, a configuration name 
		is specified using the <i>name</i> property. This name must be unique.
	</p>

	<p>
		The <code>site-data</code> element provides an optional place to set fixed
		or default remote site information. The connection strings are URIs
		which are specific to the PTP RemoteServices definitions. The scheme
		for these URIs will usually name the specific remote service (e.g,
		<code>rse:</code>
		or
		<code>remotetools:</code>
		; local is simply
		<code>file:</code>
		). The host name and port given here will appear as defaults in the
		resource manager selection wizard when you create a new connection.
	</p>

	<p>
		The principal section of the schema is devoted to defining the
		target system <code>control-data</code> part. The top-level control elements
		include attributes, files to be staged, job script to
		be generated (if any), commands specific to the resource manager, and
		the layout of the launch configuration Resources tab.
	</p>
	
	<p>
		The <code>monitor-data</code> section of the schema specifies the type of monitoring
		to be used for the target system, and any monitoring system specific information
		that might be necessary. If the <code>monitor-data</code> section is omitted, monitoring
		for the target system will be disabled. This is typically the case when 
		configuring direct access to runtime systems such as MPICH2 or Open MPI.
	</p>
	
	<h3>
		<a name="SiteData">Site Data Element</a>
	</h3>
	
	<h3>
		<a name="ControlType">Control Data Element</a>
	</h3>
	
	<p>
		The <code>control-data</code> element is used to specify the control information necessary to submit and
		control jobs to the target system, and is of type <code>control-type</code>. This type is defined as follows:
	</p>

	<img alt="ControlData" src="images/02control.png" />

	<p>The <code>control-type</code> type is divided into four main sections:</p>

	<ol>
		<li>Attribute Definitions (i.e. the <i>environment</i>)</li>
		<li>Files and Scripts</li>
		<li>Commands and Stream Parsers</li>
		<li>Launch Configuration</li>
	</ol>

	These sections are discussed in more detail below.
	
	<h3>
		<a name="AttributeType">Attribute Definitions</a>
	</h3>
	<p>
		An attribute is a variable that contains specific information used to control
		the target system. Attributes are often (but not necessarily)
		visible in the user interface. The value of an attribute can be any Java primitive type, a list of strings,
		or a map of strings.
	</p>

	<p>
		[TODO: Check if this is still correct]
		If
		<code>stdout</code>
		and
		<code>stderr</code>
		from a scheduled job is to be delivered to the client, the attributes
		<i>stdout_remote_path</i> and <i>stderr_remote_path</i> should be
		included in the resource manager attribute set. Similarly, the native
		designation for the selected queue, if used, should be linked to <i>control.queue.name</i>.
	</p>

	<img alt="Attribute" src="images/040attribute.jpeg" />

	<h4>
		<a name="AttributeMap">Attribute Map</a>
	</h4>
	<p>
		Each target system configuration constructs an "attribute map" which contains all the
		attributes known by the system. Attributes are either defined in the configuration file or
		are created dynamically as the result of processing the output from commands.
		Other configuration elements reference attributes by obtaining a
		string representation of attribute fields using the Eclipse variable resolver syntax:
		<code>
			${ptp_rm:name#element}
		</code> where <i>name</i> is the name of the attribute and <i>element</i>
		is the name of an attribute element
		(see further <a href="#AttributeType">below</a> on the
		specific elements for attributes.) 
	</p>
	<p>
		All attributes defined in the configuration are included in the map.
		The following pre-defined attributes are also added at runtime: <br>
		<br>
		<code>control.user.name</code>
		<br>
		<code>control.address</code>
		<br>
		<code>control.working.dir</code>
		<br>
		<code>executablePath</code>
		<br>
		<code>progArgs</code>
		<br>
		<code>directory</code>
		<br> <br> In addition, the following attributes may be linked (see <a
			href="#AttributeType">below</a>) to other attributes to
		provide an implementation-independent
		mechanism for referencing the queue and for any remote output files produced in
		connection with the job submission. <br> <br>
		<code>control.queue.name</code>
		<br>
		<code>stdout_remote_path</code>
		<br>
		<code>stderr_remote_path</code>
		<br>
	</p>


	<h4>
		Attribute Properties
	</h4>
	<p>
		The following properties are available when defining new attributes:
	</p>
	<table cellpadding="5" border="1" rules="all">
		<tr>
			<th>Property</th>
			<th>Description</th>
			<th>Default</th>
		</tr>
		<tr>
			<td><i>name</i></td>
			<td>
				Used to specify the name of an attribute. This name
				can then be used to look up the values of the attribute's elements.
			</td>
			<td>none</td>
		</tr>
		<tr>
			<td><i>type</i></td>
			<td>
				Specifies the type of the attribute value. The type is primarily used by the user
				interface elements to determine how values are to be input. Values can always be accessed as strings
				regardless of their type.
			</td>
			<td>String</td>
		</tr>
		<tr>
			<td><i>visible</i></td>
			<td>
				Indicates that the user will not be directly changing the value of the
				attribute via the user interface. Certain widgets (such as
				the
				<code>attribute viewer</code>
				) check this to see if the attribute should be included
				automatically in its list.
				<br>
				Always mark attributes which are the targets of <i>attribute</i>
				(see <a href="#Widget">below</a>) as <i>visible</i>="true"; if this
				value is false, the attribute will <i>always</i> be passed to the
				configuration/environment of the resource manager; selection/exclusion
				of sets of attributes pertains only to those marked
				visible.			
			</td>
			<td>true</td>
		</tr>
		<tr>
			<td><i>status</i></td>
			<td>
				An optional property for capturing the validity of the
				attribute at runtime or for a particular installation, if such
				information is made available by the system.
			</td>
			<td>true</td>
		</tr>
		<tr>
			<td><i>readOnly</i></td>
			<td>
				Used to mark the attribute as read-only. The value of a read-only attribute
				will always remain the default value.
			</td>
			<td>true</td>
		</tr>
		<tr>
			<td><i>translateBooleanAs</i></td>
			<td>
				Can be applied to
				boolean values which should be represented as strings rather than
				"true" and "false". A comma-delimited pair is used to indicate the string
				equivalent to the boolean value. e.g., "YES,NO" would mean true yields the
				string "YES" and false the string "NO".
			</td>
			<td>null</td>
		</tr>
		<tr>
			<td><i>min</i> and <i>max</i></td>
			<td>
				Used to give the upper and lower bounds for integer attributes. UI
				elements such as the spinner widget will use this information. 
			</td>
			<td>null</td>
		</tr>
	</table>
	
	<h4>
		Attribute Elements
	</h4>
	
	<p>
		Attributes are structured objects that carry more information than just a value. This information
		is specified using elements in the XML specification. Elements can be accessed using the Eclipse variable
		syntax described in the <a href="#AttributeMap">Attribute Map</a> section.
	</p>

	<table cellpadding="5" border="1" rules="all">
		<tr>
			<th>Element</th>
			<th>Description</th>
		</tr>
		<tr>
			<td><code>description</code></td>
			<td>
				Provides a brief one-sentence definition of the attribute. This information
				is displayed by the user interface.
			</td>
		</tr>
		<tr>
			<td><code>tooltip</code></td>
			<td>
				Provides a string that will be displayed when
				the mouse hovers over the attribute in the user interface.
			</td>
		</tr>
		<tr>
			<td><code>choice</code></td>
			<td>
				Provides a predetermined, fixed set of values to choose from. These are
				specified as a comma-delimited string and will appear as the items of a combo-box.
			</td>
		</tr>
		<tr>
			<td><code>items-from</code></td>
			<td>
				Links the combo items specified in a <code>choice</code> element to another
				attribute value (whose type must be
				<code>java.util.Collection</code>).
			</td>
		</tr>
		<tr>
			<td><code>default</code></td>
			<td>
				Specifies a default value for the attribute. Default values
				must be primitive types. If no default value is specified, then the
				value of the attribute will be <code>null</code>.
			</td>
		</tr>
		<tr>
			<td><code>value</code></td>
			<td>
				Represents the current value of the attribute. Only used to fetch
				the value of an attribute.
			</td>
		</tr>
		<tr>
			<td><code>link-value-to</code></td>
			<td>
				If provided, the attribute gets its value from the
				attribute specified, unless that attribute has
				an undefined (empty) value. In this case, any default defined on
				the present attribute will be used. This feature is
				primarily intended for defining dependent attributes
				whose values are not directly modified by the user.
			</td>
		</tr>
		<tr>
			<td><code>validator</code></td>
			<td>
				Specifies a validator for the attribute. Used to enforce semantics of the attribute value.
			</td>
		</tr>
	</table>
	
	<h4>
		<a name="Regex">Validators</a>
	</h4>

	<p>
		Attributes carry optional validators which allow you to
		enforce syntactic rules, numerical ranges (each with one or both
		boundaries; these are OR'd) or file-system semantics on the value when
		the user enters text.</p>

	<img alt="Validator" src="images/041validator.jpeg" />

	<p>
		The validator makes use of the
		<code>regex</code>
		type (also used in the parser or tokenizer; see <a
			href="#StreamParsers">below</a>), along with a special
		<code>file-match</code>
		type. A regex can be used to match by setting the <i>expression</i>
		property. To split the segment into tokens on the basis of the
		expression, set the <i>split</i> property to true (this applies only to
		the
		<code>match</code>
		type discussed <a href="#MatchType">below</a>). The expression should
		follow the grammar in
		<code>java.util.regex</code>
		; the <i>flags</i> are those made available in the
		<code>java.util.regex.Pattern</code>
		class (consult the Javadoc for explanations):
	</p>
	<ul>
		<li>CASE_INSENSITIVE</li>
		<li>MULTILINE</li>
		<li>DOTALL</li>
		<li>UNICODE_CASE</li>
		<li>CANON_EQ</li>
		<li>LITERAL</li>
		<li>COMMENTS</li>
		<li>UNIX_LINES</li>
	</ul>

	<p>
		These can be OR'd in the usual manner. <b>NOTE:</b> when using the
		regex on the <a href="#MatchType"><code>match</code> </a> type, the
		expression can contain variable references to be resolved in the
		environment.
	</p>

	<p>
		The <code>file-match</code> type
		specifies the attributes pertaining to
		<code>org.eclipse.core.filesystem.IFileInfo</code>. The
		<i>efsAttributes</i> property is an OR'd string of the EFS constants:
	</p>

	<ul>
		<li>ATTRIBUTE_READ_ONLY</li>
		<li>ATTRIBUTE_IMMUTABLE</li>
		<li>ATTRIBUTE_OWNER_READ</li>
		<li>ATTRIBUTE_OWNER_WRITE</li>
		<li>ATTRIBUTE_OWNER_EXECUTE</li>
		<li>ATTRIBUTE_GROUP_READ</li>
		<li>ATTRIBUTE_GROUP_WRITE</li>
		<li>ATTRIBUTE_GROUP_EXECUTE</li>
		<li>ATTRIBUTE_OTHER_READ</li>
		<li>ATTRIBUTE_OTHER_WRITE</li>
		<li>ATTRIBUTE_OTHER_EXECUTE</li>
		<li>ATTRIBUTE_EXECUTABLE</li>
		<li>ATTRIBUTE_ARCHIVE</li>
		<li>ATTRIBUTE_HIDDEN</li>
		<li>ATTRIBUTE_SYMLINK</li>
		<li>ATTRIBUTE_LINK_TARGET</li>
	</ul>

	<p>
		The <i>lastModifiedBefore</i> and <i>lastModifiedAfter</i> properties are specified using the format
		<code>yyyy/MM/dd HH:mm:ss</code>.
	</p>

	<h3>
		Files and Scripts
	</h3>
	
	This section is used to define the files and scripts that are necessary for submitting a job
	to the target system.
	
	<h4>
		<a name="Files">Managed Files</a>
	</h4>

	<p>
		A "managed file" is a file that may be required for the job, but
		which may not be present on the host on which the job will run.
		These files may either be external to Eclipse or may be generated from
		the environment in conjunction with the job
		submission, but in either case need to be copied to the target system just prior
		to it. 
	</p>

	<img alt="ManagedFiles" src="images/05managed-files.jpeg" />

	<p>
		Managed files are added to the definition in groups determined by
		their shared staging location, specified using the <code>file-staging-location</code> element, 
		which is a path relative to the working
		directory of the connection. Managed file properties are as follows:
	</p>
	
	<table cellpadding="5" border="1" rules="all">
		<tr>
			<th>Property</th>
			<th>Description</th>
			<th>Default</th>
		</tr>
		<tr>
			<td><i>name</i></td>
			<td>
				A mandatory name for the managed file.
			</td>
			<td>N/A</td>
		</tr>
		<tr>
			<td><i>uniqueIdPrefix</i></td>
			<td>
				Specify that multiple copies of a generated file should be distinguishable.
			</td>
			<td>false</td>
		</tr>
		<tr>
			<td><i>resolveContents</i></td>
			<td>
				Pass the <code>contents</code> element through the attribute resolver (see below).
			</td>
			<td>true</td>
		</tr>
		<tr>
			<td><i>deleteSourceAfterUse</i></td>
			<td>
				Specify that local copies of generated files should be retained.
			</td>
			<td>false</td>
		</tr>
		<tr>
			<td><i>deleteTargetAfterUse</i></td>
			<td>
				Specify that the file should be deleted from the target system after use (not currently
				implemented in the general case).
			</td>
			<td>false</td>
		</tr>
	</table>
	
	<p>
		<b>Note:</b> The batch script is staged by default to
		<i>.eclipsesettings</i> in the user's home directory and deleted after the submit call returns.
		However,
		it is possible to use the
		<code>file-staging-location</code>
		on the
		<code>script</code>
		element to set the batch script path explicitly.
	</p>

	<p>
		A managed file definition allows one of three possibilities as
		to specifying content:
	</p>
		
	<table cellpadding="5" border="1" rules="all">
		<tr>
			<th>Element</th>
			<th>Description</th>
		</tr>
		<tr>
			<td><code>path</code></td>
			<td>
				Specifies the location of an external file, which can be either a hard-coded path or a reference to an 
				attribute value.
			</td>
		</tr>
		<tr>
			<td><code>contents</code></td>
			<td>
				Specifies the file contents as a string. 
				In this case the <i>resolveContents</i> property is used to indicate whether to pass this string through the
				attribute resolver, substituting any references to 
				attribute values it may contain. However, this string should not contain "${...}" sequences which
				do not actually refer to Eclipse variables (such as batch script
				variables), or the resolution will fail. If <i>resolveContents</i> is
				set to false, you can still provide this text element with a single
				reference to an attribute, in which case the value of that
				attribute will be used <i>as is</i>, without further
				dereferencing.
			</td>
		</tr>
		<tr>
			<td><code>line</code></td>
			<td>
				Specifies the file contents using <code>line-type</code> elements.
				This is the preferred and most flexible way to represent the
				contents of a file to be generated. The <code>line-type</code> type is discussed in more detail
				<a href="#LineArg">below</a>.
			</td>
		</tr>
	</table>

	<p>When the submit call is executed, managed files are generated if necessary,
		then their target paths are determined as follows:</p>

	<ul>
		<li>If the <code>path</code> element is used, the target path
			becomes <i>staging_directory / name_of_pre-existing_file</i>.</li>
		<li>If the <code>content</code> or <code>line</code> elements are
			used, the target path becomes <i>staging_directory/
				[uniqueIdPrefix]managed-file-name</i>).</li>
		<li>An attribute is placed in the environment whose <i>name</i> is
			the managed-file <i>name</i> and whose <i>value</i> is this target
			path.</li>
	</ul>

	<h4>
		<a name="Script">Scripts</a>
	</h4>

	<p>
		Schedulers such as PBS
		or LoadLeveler normally use a job script in order to specify the resources
		required to launch a job (although they can be configured to work without a batch script.) 
		Using a script file generally provides the most flexibility in configuring the job submission.
		A
		<code>script-type</code>
		file is just a special
		case of the
		<code>managed-file-type</code>
		type
	</p>

	<img alt="ScriptType" src="images/06script.png" />

	<p>
		If the script is specified in the configuration, its path is
		automatically added to the list of managed files to be staged to the
		appropriate directory (by default <i>.eclipsesettings</i>, or
		as indicated by the
		<code>file-staging-location</code>
		element), so there is no need to include a script entry explicitly
		under the
		<code>managed-files</code>
		element. The following properties are available for scripts:
	</p>
	
	<table cellpadding="5" border="1" rules="all">
		<tr>
			<th>Property</th>
			<th>Description</th>
			<th>Default</th>
		</tr>
		<tr>
			<td><i>insertEnvironmentAfter</i></td>
			<td>
				Supplies a line number indicating where in the
				script to add any extra environment variables set through the <b>Environment</b>
				tab provided in the launch configuration. This provides
				control over whether these should overwrite previously
				defined environment variable values.
			</td>
			<td>-1 (don't insert)</td>
		</tr>
		<tr>
			<td><i>deleteAfterSubmit</i></td>
			<td>
				Indicates that the script target should not
				be retained. Unlike the
				<code>managed-file-type</code>, however, the local copy of the generated script is always deleted.
			</td>
			<td>true</td>
		</tr>
	</table>

 	<p>
 		A reserved attribute,
				<code>managed_file_for_script</code>, is used to reference the script's path on the target
				resource in the submit command, e.g.:
	</p>
	<p>
		<code>
			&lt;arg&gt;qsub&lt;/arg&gt;<br>
			&lt;arg&gt;${ptp_rm:managed_file_for_script#value}&lt;/arg&gt;
		</code>
	</p>

	<p>
		<b>Note</b>: If the
		<code>import</code>
		tab (see <a href="#LaunchTab">below</a>) is used to provide an
		external or workspace edited batch script to the run, nothing extra
		need be done in the configuration. The
		path for the script is handled automatically.
	</p>

	<h4>
		<a name="LineArg">Lines</a>
	</h4>

	<p>
		The <code>line-type</code> is used to explictly specify lines for a script or managed file. Each
		<code>line-type</code>
		element contains zero or more
		<code>arg-type</code>
		elements. The text specified by the <code>arg-type</code> elements is placed on a single line, separated by
		whitespace. The sequence is terminated by a line separator.
	</p>

	<img alt="Line" src="images/07line-arg.png" />

	<h4>
		<a name="Arguments">Arguments</a>
	</h4>

	<p>
		An
		<code>arg-type</code>
		element is used for script and managed file content as well as in the
		definition of commands. Its text element contains the actual argument
		string which is passed to the attribute resolver before being written
		out. The default behavior of the argument resolver is not to 
		include arguments whose values are <code>null</code>.
		The <code>arg-type</code> type provides the following properties:
	</p>
	
	<table cellpadding="5" border="1" rules="all">
		<tr>
			<th>Property</th>
			<th>Description</th>
			<th>Default</th>
		</tr>
		<tr>
			<td><i>attribute</i></td>
			<td>
				<p>
				Apply the match to the value of the referenced attribute 
				rather than the content of the element. For example,
				a boolean attribute could be used to control the inclusion/exclusion of the argument as
				follows:</p>
				</p>
				<code> &lt;arg attribute="useFlags" isUndefinedIfMatches="false"&gt;${ptp_rm:flag#value}&lt;/arg&gt; </code>
			</td>
			<td>""</td>
		</tr>
		<tr>
			<td><i>isUndefinedIfMatches</i></td>
			<td>
				<p>
				 Specifies a regular
				expression that is compared to the argument after resolution. If the regular
				expression matches, then the argument will be omitted from the result. For instance, if a
				flag should not appear when the value it precedes is an empty string,
				one could write:
				</p>
				<code> &lt;arg isUndefinedIfMatches="-f"&gt;-f
					${ptp_rm:flag#value}&lt;/arg&gt; </code>
			
				<p>For the purposes of matching, trailing whitespace is trimmed
					from the resolved argument, so there is no need to specify this as
					part of the regex used to match.</p>
			</td>
			<td>""</td>
		</tr>
		<tr>
			<td><i>resolve</i></td>
			<td>
				Indicates that the text element should be treated as a literal and no
				attribute resolution performed on the string.. The <i>resolve</i> property must be set
				to false if the string contains batch-type variables (e.g., ${HOME}) which should be
				resolved by the remote shell and not inside the Eclipse client.
			</td>
			<td>true</td>
		</tr>
	</table>
	
	<h4>
		<a name="JustInTimeEval">"Just-in-time" resolution of <i>@jobId</i>
			and <code>managed-file</code> paths</a>
	</h4>

	<p>
		<i>@jobId</i> is a special attribute name designating the runtime id
		for a job instance. In the lifecycle of the run/launch (submit) call,
		this value begins as an internally generated unique id (uuid) which then is
		replaced by the real job id <i>after</i> the job has been submitted.
	</p>

	<p>
		The <i>@jobId</i> attribute, along with the target paths for
		<code>managed-file</code>
		elements, are not known at configuration time (i.e., before the user
		hits "Run"). While the former is made visible to the parsers and the
		returned status object of the submit command, neither is in the scope
		of (available for reference in) other managed files or the
		<code>script</code>
		element, because these latter elements are generated just prior to the
		actual submission.
	</p>

	<p>
		If the
		<code>script</code>
		needs to refer to the <i>@jobId</i>, it must do so via an environment variable
		made available by the particular scheduler it is written for. An
		example of how to reference the target path of a
		<code>managed-file</code>
		inside the
		<code>script</code>
		is included in the <a href="http://download.eclipse.org/tools/ptp/docs/JAXBDemo.pdf">tutorial slides</a>. This
		essentially involves defining an environment variable in the submission command's
		environment, with a reference to the
		<code>managed-file</code>
		path attribute as its value, and then using this environment variable
		inside the
		<code>script</code>
		.
	</p>

	<h3>
		<a name="CommandsParsers">Commands and Stream Parsers</a>
	</h3>

	<p>
		Commands are used by various parts of the control system in order to communicate with and control
		aspects of the target system resource manager. Commands are system calls, either to a local or remote OS,
		depending on the connection defined for the target system. 	A command is always 
		executed through a Java API (the "process builder") which typically results in a
		<code>bash -c</code> command (possibly via an ssh connection.) The first argument of 
		the command is the name/path of the executable. Arguments are then
		specified by an arbitrary number of
		<code>arg-type</code>
		elements.
	</p>
		
	<p>
		The following commands are supported by the <code>control-data-type</code>:
	</p>
	<table cellpadding="5" border="1" rules="all">
		<tr>
			<th>Element</th>
			<th>Description</th>
		</tr>
		<tr>
			<td><code>start-up-command</code></td>
			<td>
				<p>
					A command that is run to initialize the configuration. This command is usually used
					to check for correct versions and to obtain dynamic configuration information (e.g.
					the list of available queues) from the target system
				</p>
			</td>
		</tr>
		<tr>
			<td><code>submit-interactive</code></td>
			<td>
				<p>
					Command to submit a purely interactive job to the target system. An interactive job
					is defined as one that the user would normally run from a login shell.
				</p>
			</td>
		</tr>
		<tr>
			<td><code>submit-interactive-debug</code></td>
			<td>
				<p>
					Debug version of the <code>submit-interactive</code> command.
				</p>
			</td>
		</tr>
		<tr>
			<td><code>submit-batch</code></td>
			<td>
				<p>
					Command to submit a batch job to the target system. This type of job
					submission is normally asynchronous, i.e. the user submits a job and
					at some later point the job will be run.
				</p>
			</td>
		</tr>
		<tr>
			<td><code>submit-batch-debug</code></td>
			<td>
				<p>
					Debug version of the <code>submit-batch</code> command.
				</p>
			</td>
		</tr>
		<tr>
			<td><code>get-job-status</code></td>
			<td>
				<p>
					A user-initiated (on-demand)
					request to refresh the status information for a submission. Normal
					(polled) updates, on the other hand, are the responsibility of the
					<code>monitor-type</code>
					component. The status command nevertheless needs to be implemented in
					most cases, as it will be called internally just after submission. 
				</p>
			</td>
		</tr>
		<tr>
			<td><code>terminate-job</code></td>
			<td>
				<p>
					A command to remove a job from the target system (terminating
					a running job if necessary). <b>Note</b>: if the submission type is interactive, the
					<code>terminate-job</code> command usually does not need to be implemented,
					as the process termination will be handled internally. However, in
					some cases (such as PBS -I) which require the interactive job to run
					as a pseudo-terminal, one may need this command in order to force its
					termination externally.
				</p>
			</td>
		</tr>
		<tr>
			<td><code>suspend-job</code></td>
			<td>
				<p>
					An optional command to suspend a running job.
				</p>
			</td>
		</tr>
		<tr>
			<td><code>resume-job</code></td>
			<td>
				<p>
					An optional command to resume a suspended job.
				</p>
			</td>
		</tr>
		<tr>
			<td><code>hold-job</code></td>
			<td>
				<p>
					An optional command to place a job on hold.
				</p>
			</td>
		</tr>
		<tr>
			<td><code>release-job</code></td>
			<td>
				<p>
					An optional command to release a held job.
				</p>
			</td>
		</tr>
		<tr>
			<td><code>shut-down-command</code></td>
			<td>
				<p>
					A command that is run to clean up after a job has been launched.
				</p>
			</td>
		</tr>
		<tr>
			<td><code>button-action</code></td>
			<td>
				<p>
					An arbitrary command that can be associated with a button exposed through the
					launch configuration Resources tab
					(see further <a href="#Action">below</a>).
				</p>
			</td>
		</tr>
	</table>
	
	<p>
		<b>Note: A
		configuration may only define either a batch or an interactive launch mode, although
		each launch mode
		may have only two submission modes, run and debug.
		(Future versions may allow batch and interactive to coexist in a single
		configuration.) </b>
	</p>
	
	<h4>
		<a name="CommandTypes">Command Type</A>
	</h4>
	<p>
		A <code>command-type</code> element is used to define a command. 
	</p>
	
	<img alt="CommandType" src="images/08command.png" />

	<p>
		The following properties are available for a
		<code>command-type</code>
		element:
	</p>
	<table cellpadding="5" border="1" rules="all">
		<tr>
			<th>Property</th>
			<th>Description</th>
			<th>Default</th>
		</tr>
		<tr>
			<td><i>name</i></td>
			<td>
				Specifies
				a name for the command.
			</td>
			<td>N/A</td>
		</tr>
		<tr>
			<td><i>directory</i></td>
			<td>
				Specifies
				where the command will be executed. <b>This
				defaults to the "home" or working directory of the remote control
				connection (the <code>control.working.dir</code> attribute)</b>.
			</td>
			<td><code>control.working.dir</code></td>
		</tr>
		<tr>
			<td><i>redirectStderr</i></td>
			<td>
				Specifies
				that both output and error
				streams are sent back on <code>stdout</code>.
			</td>
			<td>false</td>
		</tr>
		<tr>
			<td><i>streamBufferLimit</i></td>
			<td>
				Specifies
				the buffer limit for stream readers.
			</td>
			<td>-1 (use system defined)</td>
		</tr>
		<tr>
			<td><i>replaceEnvironment</i></td>
			<td>
				Specifies that the environment set on the
				command should entirely replace the shell environment
			</td>
			<td>false (append the command environment)</td>
		</tr>
		<tr>
			<td><i>waitForId</i></td>
			<td>
				Specifies that the output stream
				for the command is being parsed for an id which will appear as an
				attribute in the environment during the command execution, and that the
				execution should not return until it sees this id. Most
				submit commands will have these semantics.
			</td>
			<td>false</td>
		</tr>
		<tr>
			<td><i>ignoreExitStatus</i></td>
			<td>
				Prevents an error being thrown 
				in the case of non-zero exit of the command. This is usually used in the case of 
				a command that incorrectly returns a non-zero exit status.
			</td>
			<td>false</td>
		</tr>
		<tr>
			<td><i>keepOpen</i></td>
			<td>
				Specifies that the command should be held open for potentially repeated
				redirection of input, such as when sending commands to an interactive
				partition that has been allocated by a batch scheduler. There can only be one such
				command open at a time.
			</td>
			<td>false</td>
		</tr>
		<tr>
			<td><i>flags</i></td>
			<td>
				Specifies additional flags that will be passed to the remote connection.
				The <i>flags</i> property is an OR'd string of three possible values:
				<ul>
					<li>NONE</li>
					<li>ALLOCATE_PTY - allocates a pseudo-terminal</li>
					<li>FORWARD_X11 - enables X11 forwarding on the connection</li>
				</ul>
			</td>
			<td>NONE</td>
		</tr>
	</table>

	<p>
		Commands that set the <i>waitForId</i> property to true are treated specially. These are
		job submission commands which produce a job id to replace the internally generated uuid, and
		are responsible for setting the <i>status</i> property of the @jobId attribute.
	</p>
	<br>
	<table align="CENTER" border="1" cellpadding="5" rules="all">
		<tr>
			<th>COMMAND TYPE</th>
			<th>TOKENIZER STATES</th>
		</tr>
		<tr>
			<td>batch</td>
			<td>SUBMITTED</td>
		</tr>
		<tr>
			<td>interactive</td>
			<td>RUNNING</td>
		</tr>
		<tr>
			<td>interactive, keepOpen</td>
			<td>SUBMITTED, RUNNING</td>
		</tr>
	</table>
	<br>
	<p>
		This table shows the various states that must be set depending on
		whether the command is interactive or batch. Commands that wait for
		an id must be provided with a <a href="#StreamParsers">stream tokenizer</a> 
		which recognizes and sets the @jobId state. Batch jobs will usually have a
		tokenizer which recognizes and sets the state to SUBMITTED when the job is
		submitted. The monitoring system will normally handle setting the job state
		to RUNNING (although this may also be done by the get-job-status command.)
		Interactive jobs, which just run the command as soon as possible,
		can set the job status directly to RUNNING. In the case of interactive
		jobs that set keepOpen=true (e.g., <code>qsub -I</code>
		for PBS, which also requires a pseudo-terminal to connect remotely),
		there will usually be a pause before the terminal job is actually
		scheduled. In order to allow the user to see that the job has been
		accepted and is pending, the tokenizer needs to set both SUBMITTED and
		RUNNING states, the latter when the job has actually started.
	</p>

	<p>
		Command <code>arg</code> elements, the <code>input</code> element, and the <code>environment</code> element all 
		make use of the <a href="Arguments"><code>arg-type</code></a> type for specifying arguments. For the
		<code>name-value-pair</code>
		type comprising the latter one can as simple alternative set the <i>value</i>
		attribute to a string (which will be resolved first in the current
		environment); finer-grained control over the resolution of the value,
		however, requires the use of the
		<code>arg</code>
		type. When there is
		<code>input</code>
		present, it is directed to the input stream of the command. If the <i>keepOpen</i>
		attribute is true, a check will be made to see if there already exists
		an open process (which is also alive), which will then be used;
		otherwise, the arguments are executed, then the input arguments are
		given to the process. With an open command/process, the input
		arguments can be fed repeatedly to the same process; this allows, for
		instance, for continuous testing of an interactive job in the same
		interactive session.
	</p>
	
	<h4>
		Execution Environment
	</h4>
	
	<p>
		The <code>environment</code> element allows attribute values to be passed to the command's environment
		prior to execution. 
	</p>

	<img alt="EnvironmentType" src="images/092environment.png" />

	<p>
		In the simplest form, the <i>name</i> and <i>value</i> properties are used to specify
		the name of the environment variable, and a corresponding value that can be resolved from the attribute
		map. Finer control of the environment variable can be obtained by using the <code>arg-type</code> type.
	</p>
	
	<p>
		The <i>preserve</i> property can be used to override the <code>command-type</code> <i>replaceEnvironment</i> property.
		If this property is set to true, this environment variable will be passed to the remote command regardless
		of the <i>replaceEnvironment</i> property setting.
	</p>

	<h4>
		<a name="StreamParsers">Stream Parsers</a>
	</h4>

	<p>
		It is possible to attach a parser (which we also refer to as a tokenizer) to the
		output and error streams of any
		<code>command-type</code>
		in order to capture information and use it to side-effect existing
		attributes, or to generate new ones on the fly. While
		the parser is not completely general, it is capable of a wide range of
		tasks which would typically be required in the handling of output from
		batch and runtime systems.
	</p>
	
	<img alt="TokenizerType" src="images/090tokenizer.png" />

	<p>
	  	The main parser elements used by the tokenizer are
		<code>target</code>, <code>match</code>, and <code>test</code>.
		See the <a
			href="#TokenizerExamples">tokenizer examples</a> demonstrating
		various usage scenarios.
	</p>
	<p>
		The
		<code>type</code>
		element will most commonly not be set, meaning the built-in parser
		will be used; however, it is possible to implement a custom parser as
		a contribution to the
		<code>org.eclipse.ptp.rm.jaxb.core.streamParserTokenizer</code>
		extension point, in which case this element should be set to its
		extension id. Note that the extension requires the class to implement
		<code>org.eclipse.ptp.rm.jaxb.control.internal.IStreamParserTokenizer</code>, 
		which is a Runnable interface with an initialize method which passes
		in any job id plus the current environment map; the details of such a
		parser's implementation are not, however, configured from the XML
		document.
	</p>

	<p>
		The built-in tokenizer can read the stream in two different ways. If <i>delim</i>
		is provided, the stream is split using the indicated value. The string
		should only be one character in length (escaped or non-escaped).
		Provision is made for the '\r\n' (Windows) two-character delimiter
		internally; in this case the delimiter should be set to "\r" (however,
		as already mentioned, PTP does not generally guarantee that system
		calls will work on Windows). Setting <i>includeDelim</i> means that
		the delimiter will appear as the last char on the returned stream
		segment.
	</p>

	<p>
		The second way to read from the stream is to provide a <i>maxMatchLen</i>
		size; what this indicates is that whatever substring needs to be found
		on the stream will not exceed this length. The stream is then read in
		swatches of <i>maxMatchLen</i>, with the internal buffer set to twice
		this size, so that each successive read shifts the buffer to the
		"left" by one length. This guarantees that all such substrings will
		eventually be matched.
	</p>

	<p>
		Sometimes a sort of "look-ahead" paradigm is necessary. For instance,
		one may need to match a segment or segments whose position is defined
		from the end of the output, but you do not know in advance the actual
		stream length. In this case, one can opt to read until the end of the
		stream (<i>all</i>="true"), retaining only the last <i>N</i>
		buffer-lengths or delimited segments, as indicated by the <i>save</i>
		field. When the parser reaches the end of the stream, it will then
		apply the various targets to each saved segment in order.
	</p>

	<p>
		<i>applyToAll</i> is discussed further under
		<code>target</code>
		. The
		<code>exit-on</code>
		element indicates that the tokenizer should quit immediately when it
		encounters this pattern;
		<code>exit-after</code>
		indicates that the tokenizer should quit when it encounters this
		pattern, but should first apply the current segment to its targets.
	</p>

	<h5>
		<a name="TargetType">Target Type</a>
	</h5>

	<img alt="TargetType" src="images/091target.png" />

	<p>
		A tokenizer may be given any number of
		<code>target</code>
		elements. The target denotes a particular value (object) currently in,
		or to be written to, the environment, which will be side-effected on
		the basis of the result of the tokenization. A target in turn contains
		<code>match</code>
		elements and
		<code>test</code>
		elements; the former are run as part of the stream processing; the
		latter are run after the stream processing has been completed. The
		optional
		<code>else</code>
		element is applied only if there are no other tests defined or if none
		of the defined tests succeed).
	</p>

	<p>
		The target object is either to be constructed at match time, or it
		pre-exists in the environment. If not constructed, <i>ref</i> points to the name of the
		<code>attribute</code>
		in the environment (recall that for the runtime job identifier, <i>@jobId</i>
		is used).
	</p>
	<p>
		<b>Note</b>: when new targets are constructed, there is a merge
		operation at the end of tokenization which attempts to combine objects
		into a single instance identified by their <i>name</i> attribute. This
		assumes that such names will be unique and that any other values to be
		set on the object which are not explicitly bound in some way to that
		name via the match pattern will appear on the stream before a new name
		does (see ex. 5 in <a href="#TokenizerExamples">tokenizer examples</a>).
		<b><i>The default behavior of this merge is that it will fail
				if two objects with the same name but differing values are generated
				by the parsing.</i> (This excludes <code>add</code> and <code>put</code>
			operations which create a list or map; in these cases, the two
			collections or maps will be combined into one. This does <i>NOT</i>
			work, however, for <code>append</code> actions.) To allow duplicates,
			set the <i>allowOverwrites</i> to true; in this case, successive
			duplicates simply replace the preceding object. </b>
	</p>

	<p>The default behavior of the tokenizer read-match sequence is as
		follows:</p>

	<ol>
		<li>read from the stream either a set number of chars or until
			the delimiter is found;</li>
		<li>for each target:
			<ul>
				<li>for each match:
					<ul>
						<li>if the match is positive, process each of the actions,
							and go to (1).</li>
					</ul>
			</ul></li>
	</ol>

	<p>
		Only one qualifying target is processed for any given segment read,
		and for the given target, the first pattern matched is the one
		processed for its actions. This is basically the "OR" semantics of
		normal logic programming; hence <i>the implementer must be careful
			to arrange the matches inside a target in such a way that the more
			specific match patterns precede the more general</i>.
	</p>
	<p>Three boolean fields allow you to modify this behavior.</p>

	<ol>
		<li>The <i>applyToAll</i> field on the <code>tokenizer-type</code>
			element means take the unmatched part of the read stream and pass it
			to the next target, even if there was a previous match; this allows
			you to capture more than one regex pattern per stream segment (see
			ex. 6 in <a href="#TokenizerExamples">tokenizer examples</a>).</li>
		<li>The <i>matchAll</i> field on the <code>target-type</code>
			element means do not try to match an already matched expression until
			all the others are matched (i.e., a logical AND instead of OR governs
			the set of matches at successive calls to the target match
			operation); this allows one to use, for instance, .* repeatedly but
			set different fields of the object with the resulting match (see ex.
			5 in <a href="#TokenizerExamples">tokenizer examples</a>).</li>
		<li>The <i>moveToTop</i> field on the <code>match-type</code>
			element indicates to the tokenizer that the matched target be
			promoted to first position in the list of targets. This is useful
			when there is an ordering which expects types of attributes
			to be grouped in sequence on the stream (see ex. 4 in <a
			href="#TokenizerExamples">tokenizer examples</a>).</li>
	</ol>

	<p>When a match is found, the set of action types it contains are
		all applied.</p>

	<h5>
		<a name="MatchType">Match Type</a>
	</h5>

	<img alt="MatchType" src="images/10match.jpeg" />

	<p>Each of these types corresponds to an action to be taken on the
		indicated field of the target object.</p>

	<table border="1" cellpadding="5" align="center" rules="all">
		<tr>
			<th>Element</th>
			<th>Description</th>
		<tr>
		<tr>
			<td><code>set</code></td>
			<td>sets the value of that field</td>
		</tr>
		<tr>
			<td><code>append</code></td>
			<td>adds to a string buffer, whose string value will be set on
				the field</td>
		</tr>
		<tr>
			<td><code>add</code></td>
			<td>adds to a list to which the value of that field will be set</td>
		</tr>
		<tr>
			<td><code>put</code></td>
			<td>places a key-value pair in a map to which the value of that
				field will be set</td>
		</tr>
		<tr>
			<td><code>throw</code></td>
			<td>throws an exception and (optionally) also sets the value of
				the field</td>
		</tr>
	</table>

	<p>
		The actions listed here all have
		<code>entry-type</code>
		children, either single (
		<code>set, throw</code>
		) or potentially multiple. All of these except
		<code>throw</code>
		also allow you to force the creation of a new object (<i>forceNewObject</i>)
		each time it is applied; the new object then replaces the current one
		for successive actions in the match.
	</p>

	<h5>
		<a name="EntryType">Entry Type</a>
	</h5>

	<img alt="EntryType" src="images/11entry.jpeg" />

	<p>
		This value-abstraction allows one to set <i>key</i> (for maps) and <i>value</i>
		as literals or references to other attributes to be
		resolved in the current environment; to reference the matched segment
		parts one sets <i>keyIndex</i> and <i>valueIndex</i> if the regex was
		used to split the segment; otherwise, <i>keyGroup</i> and <i>valueGroup</i>
		refer to the capture group of the regex pattern, with group 0
		referring to the entire match.
	</p>

	<h5>
		<a name="TestType">Test Type</a>
	</h5>

	<img alt="TestType" src="images/12test.jpeg" />

	<p>
		As mentioned <a href="#TargetType">above</a>, the
		<code>test-type</code>
		elements are all run after the tokenization has reached the end of the
		stream. This class of actions is useful for setting values based on
		other values produced during tokenization. A test is one or more
		comparison operations plus a set of actions to apply to the target
		fields in the case of either success or failure (the "else" element);
		see ex. 3 or the "get-job-status" example in <a
			href="#TokenizerExamples">tokenizer examples</a>.
	</p>

	<p>
		The <i>op</i> attribute can be one of the following comparisons:
	</p>

	<table align="center">
		<tr>
			<td>EQ</td>
			<td>:</td>
			<td>equals</td>
		</tr>
		<tr>
			<td>LT</td>
			<td>:</td>
			<td>less than</td>
		</tr>
		<tr>
			<td>LE</td>
			<td>:</td>
			<td>less than or equal to</td>
		</tr>
		<tr>
			<td>GT</td>
			<td>:</td>
			<td>greater than</td>
		</tr>
		<tr>
			<td>GE</td>
			<td>:</td>
			<td>greater than or equal to</td>
		</tr>
	</table>

	<p>
		When the operation is set to one of these, it is expected that the two
		<code>value</code>
		elements will be used. As usual, these elements can be literals or can
		contain variables to be resolved into a string type;
		<code>#FIELD</code>
		refers to the value of the given field on the current target; the
		strings will be converted in conformity with the inferred (primitive)
		type of the comparison. The
		<code>else</code>
		element also pertains to comparison tests; the actions listed there
		will be taken upon failure of the comparison.
	</p>

	<p>
		The <i>op</i> attribute can also be a logical operator [AND, OR, NOT],
		in which case the embedded
		<code>test</code>
		object should be used; these can be nested to an arbitrary depth, but
		of course must bottom out in a comparison operation.
	</p>

	<h4>
		<a name="TokenizerExamples"></a><b>Contents of Tokenizer Examples
			(</b><a href="tokenizer-examples.xml">tokenizer-examples.xml</a>)
	</h4>
	<br>

	<table align="center" rules="all">
		<tr>
			<th>Example</th>
			<th>Description</th>
		</tr>
		<tr>
			<td>1</td>
			<td>output is a list of line-separated queue names to be
				assigned to the known attribute "available-queues"</td>
		</tr>
		<tr>
			<td>2</td>
			<td>output is to be searched for its final line which should
				contain a job id of the form "[digits].[chars]"</td>
		</tr>
		<tr>
			<td>3</td>
			<td>indeterminate number and order of lines containing parts of
				attribute definitions, but each line bearing a distinct id (e.g.,
				openMPI attribute discovery)</td>
		</tr>
		<tr>
			<td>4</td>
			<td>indeterminate number of definitions, but grouped by caption;
				use of <i>moveToTop</i> to promote the target to the top of the list
				when the caption appears</td>
		</tr>
		<tr>
			<td>5</td>
			<td>similar to 4, but without delimiter (implicit ordering)</td>
		</tr>
		<tr>
			<td>6</td>
			<td>similar to 4, but with indeterminate type order and using
				buffer + DOTALL | UNIX_LINES</td>
		</tr>
		<tr>
			<td>7</td>
			<td>indeterminate number of attribute definitions, but on single
				line</td>
		</tr>
		<tr>
			<td>8</td>
			<td>looking for values interspersed in the stream but which will
				not exceed 32 chars</td>
		</tr>
		<tr>
			<td>9</td>
			<td>successive names/values, in order, but staggered</td>
		</tr>
		<tr>
			<td>10</td>
			<td>forced merge</td>
		</tr>
		<tr>
			<td>11</td>
			<td>exit-on</td>
		</tr>
		<tr>
			<td>12</td>
			<td>exit-after</td>
		</tr>
		<tr>
			<td>13</td>
			<td>get-job-status (use of tests)</td>
		</tr>
	</table>
	<br>

	<h3>
		UI Configuration
	</h3>
	
	<h4>
		<a name="LaunchTab">The Resources Tab</a>
	</h4>

	<p>
		The UI component which needs to be configured in conjunction with the
		resource manager control is the <b>Launch Tab</b>, which is actually
		the main area of the <b>Resources Tab</b>, one of the six tabs
		comprising the <b>Run Configuration</b> wizard or the seven tabs
		comprising the <b>Debug Configuration</b> wizard. The purpose of this
		component is to allow the user to set up the job by providing values
		relating to resource requirements or to the properties of the job in
		general. In other words, it is in this component that the user can set
		the values on the
		<code>attribute</code>
		elements making up the configurable environment as defined in the XML.
	</p>

	<p>
		Specifying the composition and layout of this component can be tricky
		and tedious because it deals with widgets defined by the Eclipse
		<code>JFace</code>
		library and with their underlying implementation in
		<code>SWT</code>
		. We intend in the near future to provide some standard "templates"
		for typical widget groups that can be cut and pasted into the XML
		definition. Some of this can already be achieved by importing into the
		workspace a provided definition (such as for the PBS resource manager)
		and modifying it or borrowing from it. This is, in fact, the approach
		demostrated in the <a href="http://download.eclipse.org/tools/ptp/docs/JAXBDemo.pdf">tutorial</a>.
	</p>

	<p>
		<b> Throughout the following, it may generally be assumed that
			fields such as <i>style</i>, <i>foreground</i>, <i>background</i>,
			etc., take string equivalents of the corresponding <code>SWT</code>
			constants (e.g., "SWT.LEFT", "SWT.VERTICAL", "SWT.NONE") which can be
			OR'd (using "|") wherever they would be in Java code. We will <i>not</i>
			exhaustively specify here which constants pertain to which widgets,
			because in most cases we have tried to reflect very closely the names
			of the <code>SWT</code> object types and fields, and this information
			can be found by consulting the Javadocs relative to the widgets in
			question. </b>
	</p>

	<img alt="LaunchTabType" src="images/13launch-tab.jpeg" />

	<p>
		As seen from this top-level specification, the Launch Tab can have any
		number of
		<code>dynamic</code>
		tab-controllers, "dynamic" meaning configurable from the XML, which
		will discuss in more detail in the following paragraphs.
	</p>
	<p>
		There is also a fixed
		<code>import</code>
		controller type (implemented as an extension/subclass of the dynamic
		controller, in order to provide uniform handling of the environment);
		this component allows you to browse the workspace to set a custom
		script as the one to run. Its main text area widget is read-only; any
		editing of the script must be done through the workspace editor. The
		browse is local only, so remote scripts should first be imported into
		a local project in the workspace (using the remote systems import
		wizard), and then captured by this controller's browse button.
	</p>

	<p>
		The configurable part of the import tab is an optional <a
			href="#AttributeViewer">attribute viewer</a> for selecting the
		variables from the environment which you wish to pass to the launch
		command along with the script. <i>The values set here should
			correspond to whatever the script contains; they are set for the
			benefit of the internal consistency of the PTP client, and do not
			override those hard-coded in script.</i> For an example, see the <a
			href="PLUGINS_ROOT/org.eclipse.ptp.rm.jaxb.pbs.doc.user/html/PBSHelpPage.html#ImportTab">Import
			PBS Script</a> tab.
	</p>

	<h4>
		<a name="TabController">Tab Controller</a>
	</h4>

	<p>
		The
		<code>dynamic</code>
		controllers belong to the
		<code>tab-controller-type</code>, which contains an arbitrary number of
		<code>tab-folder,</code>
		<code>composite,</code>
		<code>widget,</code>
		<code>browse,</code>
		<code>button-group,</code>
		<code>action,</code>
		or
		<code>viewer</code>
		elements; as will be seen shortly, the first two, which are
		"containers", are potentially recursive elements, so that one can nest
		widgets in the usual manner. For all intents and purposes, the
		<code>tab-controller-type</code>
		is the same as a
		<code>composite</code>, but without the <i>group</i> attribute and with the extra field for
		controlling shared widgets.
	</p>

	<img alt="TabController" src="images/14tab-controller.jpeg" />
	<p>
		The <i>includeWidgetValuesFrom</i> field is important. By default, it
		is set to empty, meaning that the subset of the total resource manager
		environment represented by the controller's widgets is all that will
		be passed to the actual job configuration when the job is launched
		from this tab. This behavior can be changed by giving a
		comma-delimited list of the
		<code>title</code>
		values for other controllers. In this case, the configuration for the
		job, when the "Run" button is pressed with this controller being the
		visible one, will also include <i>all the attributes
			valid for the listed but currently invisible controllers</i>.
	</p>
	
	<blockquote>
	<div style="border: 1px solid ;">
	<h5>
		<a name="Note3">ATTRIBUTE NAMES vs VALUES</a>
	</h5>

	<p>While this field controls the inclusion or exclusion of
		attribute names in the configuration, their values are
		always shared across the controllers (there is only one environment);
		thus if a variable value is changed on one controller, and this
		variable is also exposed on another, the value for that variable will
		also change on the other controller when it becomes visible;
		similarly, if the user switches off a controller to another having
		only a subset of the first controller's variables, the variables not
		represented on the second controller will become undefined or return
		to their defaults.</p>
	<p>
		<b>Note</b> that the union of valid names is not transitively closed;
		that is, if Tab1 has <i>includeWidgetValuesFrom</i>="Tab2", and Tab2
		similarly has <i>includeWidgetValuesFrom</i>="Tab3", Tab1 will get
		only the valid values local to Tab2. <b>Note</b> also, that if there
		are names which intersect with strictly local widget targets, the
		local settings (visibility, selection, enablement) still determine
		whether they belong in the set of valid attribute names.
	</p>
	</div>
	</blockquote>
	
	<p>
		The <i>showViewConfig</i> and <i>showViewExcluded</i> fields allow
		control over whether the "View Configuration" and "View Excluded"
		buttons appear at the bottom of the tab (the "View Script" button
		appears if the configuration contains a
		<code>script</code>
		element). <i>showViewConfig</i> is true by default; this button brings
		up a scrolling dialog which allows you to inspect the current
		configuration (that is, the one relevant to the visible controller). <i>showViewExcluded</i>
		is by default false, and should only be set if the resource manager
		processes attributes discovered by a command at run
		time; this dialog allows you to see which ones have been marked
		invisible; <b>unlike invisible predefined attributes</b>,
		which are always <i>included</i>, invisible discovered
		attributes are always <i>excluded</i> from the configuration and thus
		do not persist across resource manager sessions.
	</p>
	<br>
	<h4>
		<a name="TabFolders">Tab Folders and Tab Items</a>
	</h4>

	<img alt="TabFolder" src="images/15tab-folder.jpeg" />
	<p>
		The
		<code>tab-folder</code>
		is a container which looks like a file-folder, with tabs running
		across the top or bottom (<i>style</i> includes SWT.TOP, SWT.BOTTOM).
		Each tab label corresponds to a
		<code>tab-item</code>
		which provides the actual visible content. The
		<code>tooltip</code>
		pertains to the entire folder.
	</p>

	<p>
		The
		<code>tab-item</code>
		is another all-purpose "container" in which all widget types can be
		embedded, but distinguished from the <a href="#Composite"><code>composite</code>
		</a> in that it can only be the child of a
		<code>tab-folder</code>
		and that it can have a tooltip (which appears on the tab).
	</p>

	<p>
		As with
		<code>composite</code>
		(see <a href="#Composite">below</a>), the tab folder and tab item take
		<code>layout</code>
		and
		<code>layout-data</code>
		elements; these closely reflect their
		<code>SWT</code>
		objects and types; for further explanation we refer the reader once
		again to the relevant Javadocs.
	</p>

	<h4>
		<a name="Layout">Layout</a>
	</h4>
	<img alt="Layout" src="images/17layout.jpeg" />
	<h4>
		<a name="LayoutData">Layout Data</a>
	</h4>
	<img alt="LayoutData" src="images/18layout-data.jpeg" />

	<h4>
		<a name="Composite">Composite/Group</a>
	</h4>

	<p>
		The main container, of course, is the
		<code>composite</code>
		; its sub-type, the group (<i>group</i>="true"), allows for decoration
		and a title, while the simple composite acts as a widget holder and
		has no visible characteristics, though it does have a layout. As is
		evident, composites can be contained in composites and tab-items, and
		tab-folders can be contained in composites.
	</p>

	<img alt="Composite" src="images/16composite.jpeg" />
	<br>

	<h4>
		<a name="ControlState">Control State Wiring</a>
	</h4>

	<p>
		It should be evident that all the XML elements corresponding to UI SWT
		<code>control</code>
		types have been given
		<code>control-state</code>
		children.
	</p>

	<img alt="Composite" src="images/22control-state.png" />
	<br>

	<p>
		The purpose of these elements is to provide an optional way of setting
		the <b>enabled</b> and/or <b>visible</b> states of the control on the
		basis of the state of button (checkbox/radio) selection or the value of an attribute. One can
		define two such elements per control, using one of the show/hide or
		enable/disable pairs. Each of these is associated with a
		<code>control-state-rule:</code>
	</p>

	<img alt="Composite" src="images/23control-state-rule.png" />
	<br>

	<p>The basic rule is defined by its attributes. Rules can specify either:</p>

	<ul>
		<li>the id of the button control to check (<i>button</i>)</li>
		<li>whether its selected state should be true or false (<i>selected</i>)</li>
	</ul>
	
	<p>or</p>

	<ul>
		<li>the name of an attribute (<i>attribute</i>)</li>
		<li>the value of the attribute (<i>value</i>).</li>
	</ul>

	<p>Only one combination of <i>button</i> and <i>selected</i> or <i>attribute</i> and <i>value</i> can be
	specified in a rule. Rules can be nested to an arbitrary depth to form clauses
		governed by the logical operators.</p>

	<p>
		When using a rule containing <i>button</i> and <i>selected</i>, the
		"trigger" button control must have an id unique to the resource
		manager configuration. This will be assigned via the <i>buttonId</i>
		attribute on the
		<code>widget</code>
		corresponding to the button (true also for the buttons nested in a
		<code>button-group</code>
		). For these rules, a
		<code>SelectionListener</code>
		is created for this target which subscribes to all the controls in the
		rule; when it receives an event, it evaluates the rule, and if the
		result is true, takes the associated action on this target.
	</p>
	
	<p>For rules that spectify <i>attribute</i> and <i>value</i>, the attribute value will be checked 
	when the attribute or any control is updated.</p>

	<p>Here is an example which sets the enabled and visible properties
		of both a text field and a related checkbox:</p>

	<pre>
               &lt;widget type="checkbox" buttonId="002" title="Host list:" attribute="checked002"&gt;
                  &lt;layout-data&gt;
                     &lt;grid-data horizontalAlign="SWT.LEFT" verticalAlign="SWT.TOP"/&gt;
                  &lt;/layout-data&gt;
                  &lt;control-state&gt;
                     &lt;show-if button="001" selected="true"/&gt;
                  &lt;/control-state&gt;
               &lt;/widget&gt;
               &lt;widget type="text" style="SWT.V_SCROLL | SWT.BORDER" attribute="host_list"&gt;
                  &lt;layout-data&gt;
                     &lt;grid-data horizontalAlign="SWT.FILL" verticalAlign="SWT.FILL" horizontalSpan="2" grabExcessHorizontal="true"
                        grabExcessVertical="true"/&gt;
                  &lt;/layout-data&gt;
                  &lt;control-state&gt;
                     &lt;show-if button="001" selected="true"/&gt;
                     &lt;enable-if&gt;
                        &lt;and&gt;
                           &lt;rule button="001" selected="true"/&gt;
                           &lt;rule button="002" selected="true"/&gt;
                        &lt;/and&gt;
                     &lt;/enable-if&gt;
                  &lt;/control-state&gt;
               &lt;/widget&gt; 
   </pre>

	<p>Note also that this implicit dependency graph is checked for
		cycles; the building of the UI tab will be aborted if such a cycle is
		discovered.</p>

	<blockquote>
	<div style="border: 1px solid ;">
	<h5>
		<a name="Note4">BEST PRACTICE: CONTROL STATE</a>
	</h5>
	<p>
		An invisible property should be assigned to each checkbox which
		controls the state of other widgets (e.g., <i>checked002</i> in the
		example above); this will allow you to restore the state of the tab
		correctly when it is rebuilt or re-initialized.
	</p>
	<br>
	</div>
	</blockquote>
	
	<h4>
		<a name="Widget">Widget</a>
	</h4>

	<p>
		We now come to the five non-container widget elements with functional
		characteristics. The first of these is the
		<code>widget</code>, which comprises a number of simple widget types.
	<p>

	<img alt="Widget" src="images/19widget.png" />

	<p>
		The <i>type</i> of the widget can be one of the following:
	</p>

	<br>
	<table align="center" rules="all">
		<tr>
			<td><code>label</code></td>
			<td>fixed text for display</td>
		</tr>
		<tr>
			<td><code>text</code></td>
			<td>area for entering/editing text</td>
		</tr>
		<tr>
			<td><code>checkbox</code></td>
			<td>corresponds to a boolean choice</td>
		</tr>
		<tr>
			<td><code>radiobutton</code></td>
			<td>usually used in connection with <code>button-group</code></td>
		</tr>
		<tr>
			<td><code>spinner</code></td>
			<td>provides a continuous range of integer values</td>
		</tr>
		<tr>
			<td><code>combo</code></td>
			<td>select from a list of items</td>
		</tr>
	</table>
	<br>

	<p>
		Not all attributes and elements of the
		<code>widget</code>
		descriptor are applicable to all types.
	</p>
	<br>
	<table align="center" rules="all">
		<tr>
			<td><i>title</i></td>
			<td>used with <code>checkbox</code> and <code>radiobutton</code>
				widgets for the button label.</td>
		</tr>
		<tr>
			<td><i>style</i></td>
			<td>carries the <code>SWT</code> style constants appropriate to
				the widget type.</td>
		</tr>
		<tr>
			<td><i>readOnly</i></td>
			<td>applies to <code>text</code>, <code>spinner</code> and <code>combo</code>
				widgets; the text area in this case is not editable.</td>
		</tr>
		<tr>
			<td><i>attribute</i></td>
			<td>applies to all widgets except <code>label</code>; the name
				of the attribute whose value should be set on the basis
				of the widget's "selected" value or text.<br> <b>Note:</b> use
				of this attribute is mutually exclusive with the <code>fixed-</code>
				and <code>dynamic-text</code> elements.</td>
		</tr>
		<tr>
			<td><code>items-from</code></td>
			<td>applies to the <code>combo</code> widget; indicates an
				attribute <i>value</i> (of type <code>java.util.Collection</code>)
				to use to populate the items.<br> <b>Note:</b> if a combo
				widget saves its value to an attribute and the present element on
				the widget descriptor is not set, the attribute will be checked for
				non-empty <code>choice</code> or <code>items-from</code> values,
				which then will be used to populate the combo items; the <code>items-from</code>
				field on the widget is for added flexibility (for instance, linking
				up a target attribute with another attribute providing the list of
				choices).</td>
		</tr>
		<tr>
			<td><code>fixed-text</code></td>
			<td>applies to the <code>label</code> and (read-only) <code>text</code>
				widgets; text is resolved once and remains constant thereafter.</td>
		</tr>
		<tr>
			<td><code>dynamic-text</code></td>
			<td>applies only to (read-only) <code>text</code> widgets; text
				is resolved each time there is an update of a value from the Launch
				Tab.</td>
		</tr>
	</table>
	<br>

	<p>Widget foreground, background (color) and font are in principle
		configurable, though the font setting may not always work. The tooltip
		will appear on the widget whereever it usually does.</p>
	<br>

	<h4>
		<a name="ButtonGroup">Button Group</a>
	</h4>

	<img alt="ButtonGroup" src="images/20button-group.png" />

	<p>
		The button group provides an explicit selection of a single value
		based on a mutually exclusive set of button labels. Just as with the
		<code>widget</code>, one uses <i>attribute</i> to indicate what attribute
		value to set. The
		<code>button</code>
		elements, which can be arranged horizontally or vertically using the <i>style</i>
		attribute (SWT.HORIZONTAL, SWT.VERTICAL), will be
		<code>widget</code>
		elements whose type is either <i>checkbox</i> or <i>radiobutton</i>
		(if a different widget type is given, an error will occur); the <i>attribute</i>
		attribute on the individual button will be ignored. Radio buttons are
		"sticky" in the sense that once they are selected, they cannot be
		"unchecked" until a different button in the group is selected. It is
		thus advisable always to provide a default value for the 
		attribute associated with the group value if radio buttons are used.
		If check boxes are used, they can be individually checked on and off
		(one at a time), thus allowing for the value of the group to be
		potentially empty.
	</p>

	<p>Below is an example of a button group using radio buttons,
		disposed vertically.</p>
	<br>
	<img alt="ButtonGroupExample" src="images/ButtonGroup.jpeg" />
	<br>
	<br>

	<h4>
		<a name="Browse">Browse</a>
	</h4>

	<img alt="BrowseType" src="images/190browse.png" />

	<p>
		A special widget-pair -- a text widget followed by a push button --
		allowing the user to browse directories or files from either the local
		or remote file system. Aside from the fields shared with the
		<code>widget</code>
		type, we note the following:
	</p>
	<br>
	<table align="center" rules="all">
		<tr>
			<td><i>directory</i></td>
			<td>limit the <code>browse</code> widget to directories.</td>
		</tr>
		<tr>
			<td><i>uri</i></td>
			<td>have the <code>browse</code> widget set a URI as the text
				(default is false, in which case the text is an absolute path).</td>
		</tr>
		<tr>
			<td><i>localOnly</i></td>
			<td>limit the <code>browse</code> widget to the local file
				system (otherwise, the choice of local or remote is enabled).</td>
		</tr>
	</table>
	<br>
	<p>
		Control ids,
		<code>layout</code>
		and
		<code>control-state</code>
		are specified as belonging to either the text or the button. Style
		applies only to the text widget.
	</p>
	<br>

	<h4>
		<a name="Action">Action Button</a>
	</h4>

	<br>
	<img alt="ActionType" src="images/191push-button.jpeg" />
	<br>

	<p>
		A push button which is associated with a
		<code>button-action</code>
		command. The
		<code>button-action</code>
		specifies the name of a command (
		<code>action</code>
		) defined in the XML; this can be one of the
		<code>start-up</code>
		or
		<code>shut-down</code>
		commands, or a special
		<code>button-action</code>
		command (<b>note </b>that it cannot, however, be a <a href="#Note2"><b>(uu)id</b>
		</a> command, as the Launch Tab is not coupled to any submitted jobs); the
		<code>button-action-type</code>
		also indicates whether the variable affected by the command should be
		cleared prior to the command execution, and whether the launch tab
		should be refreshed (default is true) afterward.
	</p>
	<br>

	<h4>
		<a name="AttributeViewer">Attribute Viewer</a>
	</h4>

	<img alt="AttributeViewerType" src="images/21attribute-viewer.jpeg" />

	<p>
		The last of the widget types, the
		<code>attribute-viewer</code>, displays visible attributes in a table or tree
		viewer, with the value columns as editable widgets. The type of cell
		editor is determined implicitly here by the type of the
		attribute; the presence of a combo editor is determined by an
		attribute whose
		<code>choice</code>
		or
		<code>items-from</code>
		element is defined. (This is the only viable possibility for a combo
		in the table, as there would also need to be a target to save the
		selected item to, viz., the value of this same attribute.)
	</p>

	<p>Each entry in the viewer is provided with a checkbox to indicate
		which attributes have been chosen (and thus marked valid). A checkbox
		is also placed above the viewer to allow for filtering the unchecked
		items. The viewer outputs its values to the environment. The name of
		the viewer is also stored against a string of all selected values,
		constructed from a template (further discussion at the end of this
		section).</p>

	<p>
		The viewer <i>type</i> can be either "table" or "tree"; in the case of
		the tree, the type, default, status and description fields of the
		attribute are displayed as collapsible child rows hanging
		off the main name entry. Either table or tree can have up to <b>six</b>
		columns whose names/types are based on the following
		attribute fields:
	</p>

	<table align="center" rules="all">
		<tr>
			<td><b>Name</b></td>
		</tr>
		<tr>
			<td><b>Value</b></td>
		</tr>
		<tr>
			<td><b>Type</b></td>
		</tr>
		<tr>
			<td><b>Status</b></td>
		</tr>
		<tr>
			<td><b>Default</b></td>
		</tr>
		<tr>
			<td><b>Description</b></td>
		</tr>
	</table>
	<br>
	<p>
		These can appear in any order. There is a slight difference in how
		these columns are treated, depending upon whether <i>tree</i> or <i>table</i>
		is chosen as type. For <b>table</b> type, the value of the field
		simply appears in the corresponding column:
	</p>
	<br>
	<img alt="Table" src="images/Table.jpg" />
	<br>
	<br>
	<p>
		In the <b>tree</b> type, the
		<code>name</code>
		field displays all fields except
		<code>value</code>
		as children;
		<code>value</code>
		always appears as a separate column on the same row as the name (it
		contains the cell editor). If the viewer also has the column
		corresponding to the child field, that field value appears in that
		column;
	</p>

	<br>
	<img alt="Tree1" src="images/Tree1.jpg" />
	<br>
	<br>

	<p>
		Otherwise, the child fields display their value in the value column
		along with the actual
		<code>value</code>
		field:
	</p>

	<br>
	<img alt="Tree2" src="images/Tree2.jpg" />
	<br>
	<br>

	<p>
		Tooltips for the column appear when hovering over the column header. (<i>A
			caveat on the foreground and background settings for this type: they
			are exposed here but may not work as expected: these are currently
			applied to the column through the cell label provider; foreground
			does not change the font color but applies the color to the entire
			cell.</i>)
	</p>

	<p>
		<i>sort</i> is done on the name field/column. This is a toggle sort,
		such that alternate clicks reverse the sort direction. <i>headerVisible</i>
		and <i>linesVisible</i> control the look of the table. <i>tooltipEnabled</i>
		enables column-viewer label provider tooltip support. The tooltip
		defined for an attribute will appear on the row of the table or the
		parent node of the tree. The attribute description will also appear as
		a tooltip on the description columns if they exist.
	</p>

	<p>
		Control over the actual contents of the viewer is achieved through the
		<code>viewer-items-type</code>
		; one can here explicitly list attributes for inclusion
		using the
		<code>include</code>
		element, or one can set one or both of the <i>all</i> attributes; in
		the latter case, attributes can be excluded from the
		set using
		<code>exclude</code>. The <i>initialAllChecked</i> attribute, which defaults to true, indicates
		that if the attribute is new or undefined from a previous
		session, it will appear as checked; turn this off if you want new
		attributes to appear at first as unchecked.
	</p>

	<p>
		An attribute bearing the name given to this widget is written to the
		environment at each update/refresh; the value of the attribute is a
		string formed from the selected (checked) rows of the table using the
		<code>template-type</code>
		(the
		<code>value</code>
		element). The <i>pattern</i> can be any literal string embedding <i>@name</i>
		and <i>@value</i> tags as placeholders for the row's name and value;
		for instance, '@name="@value"' would generate a string of name-value
		assignments. The default <i>separator</i> between patterned segments
		is a single space.
	</p>

	<p>Below is a fuller example of the tree version of the attribute
		viewer. The text area above it displays the current value of its
		templated pattern string. The child rows reporting status, default,
		etc., cannot be selected or unselected (only the parent row can).
		Hovering over the name (here walltime) displays the tooltip.</p>
	<br>
	<img alt="AttributeViewerTree" src="images/AttribViewerTree.jpeg" />
	<br>

	<h3>
		<a name="MonitorType">The Monitor Data Type</a>
	</h3>

	<p>At present, the monitor component has less elements to define;
		this may change in future releases, when certain hard-coded features
		of the driver may be handed over to the client for configuration.</p>

	<img alt="MonitorType" src="images/24monitor.jpeg" />

	<p>
		This component can be furnished with its own set of attributes
		(currently unused). What is necessary to set at present is only the <i>schedulerType</i>
		attribute (e.g., "PBS"). <i>refreshFrequencyInSeconds</i> defaults to
		60, but this can be changed according to the needs of the user. Be
		aware that too low a setting will probably not work, as the command on
		an average sized system will take upwards of five seconds to complete
		(XML is being streamed to the driver and a
		<code>diff</code>
		is sent back to the client ).
	</p>

	<p>
		If the
		<code>driver</code>
		element is configured, then the default behavior, which is to stage
		over the necessary driver scripts to the <i>.eclipsesettings</i>
		directory in the user's home, is overridden by connecting to a
		pre-existent installation. This can be specified either using the
		<code>url</code>, or a combination of the
		<code>name</code>,
		<code>path</code>
		and
		<code>args</code>
		elements.
	</p>
	<hr>
	<a href="toc.html">Back to Table of Contents</a>
</body>
</html>
