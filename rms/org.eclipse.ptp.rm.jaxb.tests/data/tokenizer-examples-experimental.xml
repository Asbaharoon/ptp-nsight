<?xml version="1.0" encoding="UTF-8"?>
<resource-manager-builder xmlns="http://org.eclipse.ptp/rm" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="resource_manager_type.xsd" name="tokenizer-examples-experimental">
	<control-data>
		<!-- EXAMPLE 1: output is a list of line-separated queue names to be assigned
			to the known property "available-queues" -->
		<start-up-command name="test01ParseQstat">
			<arg/>
			<stdout-parser delim="\n">
				<match>
					<expression>([\w\d]+)</expression>
					<property name="queues">
					   <add>@1</add>
					</property>
				</match>
			</stdout-parser>
		</start-up-command>
		<!-- EXAMPLE 2: output is to be searched for its final line which should
			contain a job id of the form "[digits].[chars]" -->
		<start-up-command name="test02JobId" waitForId="true">
			<arg/>
			<stdout-parser delim="\n" all="true" save="1">
				<match>
					<expression>([\d]+)([.])(.+)[\s]+.*</expression>
					<property name="jobId" name="@1@2@3" default="@1" value="SUBMITTED"/>
				</match>
				<match>
					<expression>([\d]+)[.].+</expression>
					<property name="jobId" name="@0" default="@1" value="SUBMITTED"/>
				</match>
				<match>
					<expression flags="DOTALL">.*Job not submitted.*</expression>
					<property name="jobId" value="FAILED"/>
				</match>
			</stdout-parser>
			<stderr-parser delim="\n">
				<match>
					<expression>.*Job not submitted.*</expression>
					<throw message="Job Submit Failed"/>
				</match>
			</stderr-parser>
		</start-up-command>
		<!-- EXAMPLE 3: indeterminate number and order of lines containing parts
			of attribute definitions, but each line bearing a distinct
			id (e.g., openMPI attribute discovery) -->
		<start-up-command name="test03OpenMPI">
			<arg/>
			<stdout-parser delim="\n">
				<match>
					<expression>mca:.*:param:([^:]*):value:(.*)</expression>
					<attribute name="@1" visible="true" value="@2"/>
				</match>
				<match>
					<expression>mca:.*:param:([^:]*):status:(.*)</expression>
					<attribute name="@1" status="@2"/>
				</match>
				<match>
					<expression>mca:.*:param:([^:]*):help:(.*)</expression>
					<attribute name="@1" tooltip="@2"/>
				</match>
				<match>
					<expression>ompi:version:full:([\d]+)[.]([\d]+).*</expression>
					<attribute name="ompi_major_version" value="@1" visible="true" readOnly="true"/>
					<attribute name="ompi_minor_version" value="@2" visible="true" readOnly="true"/>
				</match>
				<match>
					<expression>(.*):([^:]*)</expression>
					<attribute name="@1" visible="false" readOnly="true" value="@2"/>
				</match>
				<test op="EQ" status="read-only">
					<attribute readOnly="true"/>
					<else>
						<attribute readOnly="true"/>
					</else>
				</test>
				<test op="AND">
					<test op="EQ" name="ompi_minor_version"/>
					<test op="LT" value="7"/>
					<throw message="Only supports Open MPI 1.7 and later"/>
				</test>
			</stdout-parser>
		</start-up-command>
		<!-- EXAMPLE 4: indeterminate number of definitions, but grouped
			by caption; use of moveToTop to promote the target to the top of the list
			when the caption appears -->
		<!-- TARGET ELIMINATED; Example no longer valid; Example 6 is model for this -->

		<!-- EXAMPLE 5: implicit ordering, use of AND -->
		<start-up-command name="test05ImplicitOrdering">
			<arg/>
			<stdout-parser delim="\n" matchAll="true"> <!-- tokenizer now carries the AND/OR switch on matches -->
				<match>
					<expression>.+</expression>
					<attribute name="@0"/>
				</match>
				<match>
					<expression>.*</expression>
					<attribute description="@0"/>
				</match>
				<match>
					<expression>.*</expression>
					<attribute tooltip="@0"/>
				</match>
				<match>
					<expression>.*</expression>
					<attribute value="@0"/>
				</match>
			</stdout-parser>
		</start-up-command>
		<!-- EXAMPLE 6: similar to 4, but with indeterminate type order and using buffer + DOTALL | UNIX_LINES -->
		<!-- TARGET eliminated; applyToAll no longer an option -->
		<start-up-command name="test06ImplicitWithTagsDotall">
			<arg/>
			<stdout-parser maxMatchLen="512">
				<match>
					<expression flags="DOTALL | UNIX_LINES">.*PROPERTY[\n]name:(\w*)[\n]value:([\d.-]*).*</expression>
					<property name="@1" value="@2"/>
				</match>
				<match>
					<expression flags="DOTALL | UNIX_LINES">.*PROPERTY[\n]value:([\d.-]*)[\n]name:(\w*).*</expression>
					<property name="@2" value="@1"/>
				</match>
				<match>
					<expression flags="DOTALL | UNIX_LINES">.*ATTRIBUTE[\n]name:(\w*)[\n]value:([\d.-]*).*</expression>
					<property name="@1" value="@2"/>
				</match>
				<match>
					<expression flags="DOTALL | UNIX_LINES">.*ATTRIBUTE[\n]value:([\d.-]*)[\n]name:(\w*).*</expression>
					<property name="@2" value="@1"/>
				</match>
			</stdout-parser>
		</start-up-command>
		<!-- EXAMPLE 7: indeterminate number of property definitions, but on single line -->
		<start-up-command name="test07PropertyDefsSingleLine">
			<arg/>
			<stdout-parser delim="\n">
				<match>
					<expression expression="&lt;name&gt;(.*)&lt;/name&gt;&lt;value&gt;(.*)&lt;/value&gt;"/>
					<property name="@1" value="@2"/>
				</match>
			</stdout-parser>
		</start-up-command>
		<!-- EXAMPLE 8: looking for values interspersed in the stream but which will
			not exceed 32 chars -->
		<start-up-command name="test08JobStates">
			<arg/>
			<stdout-parser maxMatchLen="32">
				<match>
					<expression flags="DOTALL | UNIX_LINES">.*&lt;job&gt;([\d]*):([\w]*)&lt;/job&gt;.*</expression>
					<property name="jobStates">
					    <put key="@1" value="@2"/>
					</property>
				</match>
			</stdout-parser>
		</start-up-command>
		<!-- EXAMPLE 9: successive names/values, in order, but staggered -->
		<start-up-command name="test09Staggered">
			<arg/>
			<stdout-parser delim="\n">
				<match>
					<expression>name:(.*)</expression>
					<property name="@1"/>
				</match>
				<match>
					<expression>value:(.*)</expression>
					<property value="@1"/>
				</match>
			</stdout-parser>
		</start-up-command>
		<!-- EXAMPLE 10: forced merge -->
		<start-up-command name="test10Merged">
			<arg/>
			<stdout-parser delim="\n">
				<match>
					<expression>name:(.+);value:(.+)</expression>
					<property name="@1" value="@2"/>
				</match>
				<match>
					<expression>name:(.+);default:(.+)</expression>
					<property name="@1" default="@2"/>
				</match>
			</stdout-parser>
		</start-up-command>
		<!-- EXAMPLE 11: exit-on -->
		<start-up-command name="test11ExitOn">
			<arg/>
			<stdout-parser maxMatchLen="32">
				<match>
					<expression flags="DOTALL | UNIX_LINES">.*&lt;job&gt;([\d]*):([\w]*)&lt;/job&gt;.*</expression>
					<property name="jobStates">
                   <put key="@1" value="@2"/>
               </property>
				</match>
				<exit-on flags="DOTALL | UNIX_LINES">.*EXIT.*</exit-on>
			</stdout-parser>
		</start-up-command>
		<!-- EXAMPLE 12: exit-after -->
		<start-up-command name="test12ExitAfter">
			<arg/>
			<stdout-parser maxMatchLen="32">
				<match>
					<expression flags="DOTALL | UNIX_LINES">.*&lt;job&gt;([\d]*):([\w]*)&lt;/job&gt;.*</expression>
					<property name="jobStates">
                   <put key="@1" value="@2"/>
               </property>
				</match>
				<exit-after flags="DOTALL | UNIX_LINES">.*EXIT.*</exit-after>
			</stdout-parser>
		</start-up-command>
		<submit-interactive name="empty">
			<arg/>
		</submit-interactive>
		<!-- EXAMPLE 13: get-status (use of tests) -->
		<get-job-status name="get-job-status" ignoreExitStatus="true">
			<arg>qstat</arg>
			<arg>${ptp_rm:@jobId#name}</arg>
			<stdout-parser delim="\n">
				<target ref="@jobId">
					<match>
						<expression>[\d]+[.].+[\s]+.+[\s]+.+[\s]+.+[\s]+([A-Z])[\s]+.+</expression>
						<property name="jobId"  value="@1"/>
					</match>
					<test name="jobId" op="EQ" value="Q">
						<property name="jobId"  value="QUEUED_ACTIVE"/>
					</test>
					<test name="jobId" op="EQ" value="R">
						<property name="jobId"  value="RUNNING"/>
					</test>
					<test name="jobId" op="EQ" value="S">
						<property name="jobId"  value="SUSPENDED"/>
					</test>
					<test name="jobId" op="EQ" value="H">
						<property name="jobId"  value="SYSTEM_ON_HOLD"/>
					</test>
					<else>
						<property name="jobId"  value="COMPLETED"/>
					</else>
				</target>
			</stdout-parser>
			<stderr-parser delim="\n">
				<match>
					<expression>.+</expression>
					<property name="jobId"  value="COMPLETED"/>
				</match>
			</stderr-parser>
		</get-job-status>
	</control-data>
	<monitor-data schedulerType="test"/>
</resource-manager-builder>